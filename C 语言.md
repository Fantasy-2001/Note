# C 语言



## 转义字符

![image-20220116174517583](https://gitee.com/Fantasy2001/images/raw/master/Markdown/C%E8%AF%AD%E8%A8%80/%E8%BD%AC%E4%B9%89%E5%AD%97%E7%AC%A6%E8%A1%A8.png)



## 常量

```c
#define NAME Value		//常量的定义
const int MONTHS = 12;		//const用于限定一个变量为只读
```



## 数据类型

![image-20220117160552263](https://gitee.com/Fantasy2001/images/raw/master/Markdown/C%E8%AF%AD%E8%A8%80/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B.png)



### 基本类型

![image-20220117161528056](https://gitee.com/Fantasy2001/images/raw/master/Markdown/C%E8%AF%AD%E8%A8%80/%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B.png)



### sizeof 运算符

```C
/*有以下三种写法*/
sizeof(object);		//sizeof(对象);
sizeof(type_name);	//sizeof(类型);
sizeof object;		//sizeof 对象;

/*例子*/
int i = 100;
sizeof(i);
sizeof(int);
sizeof i;
```



### signed 和 unsigned

> signed 带符号位
>
> unsigned 不带符号位

假设一个char为一个字节也就是八位，第一位为符号位，剩余的比特位用于表示值。所以取值范围是127~-128（00000000 = 十进制的 0 ，11111111 = -1）



### 补码

一字节有八位，第一位是符号位，0 表示 +，1表示 -
00000111（3）
11111000（先取反）
11111001（再+1，因为00000000是十进制中的0，所以负数比正数多1。因此多了这一步）
11111001（-3）
（3 - 3）== 00000111 + 11111001 = 100000000
这里的结果是 9 位，对于一个字节单元来说，这左边的 1 是“溢出”的了，会被自动舍弃，因此结果就变成了 00000000。

> 补码的好处：
>
> 1. 解决了符号的表示的问题。
> 2. 在计算机中，利用电子器件的特点实现补码和真值、原码之间的相互转换，非常容易。
> 3. 补码表示统一了符号位和数值位，使得符号位可以和数值位一起直接参与运算，这也为后面设计乘法器除法器等运算器件提供了极大的方便。



## 格式化输出/输入

**转换说明及其打印的输出结果**

| 转换说明 |                             输出                             |
| :------: | :----------------------------------------------------------: |
|    %a    |           浮点数、十六进制数和 p 记书法（C99/C11）           |
|    %A    |           浮点数、十六进制数和 p 记数法（C99/C11）           |
|    %c    |                           单个字符                           |
|    %d    |                       有符号十进制整数                       |
|    %e    |                       浮点数，e 记数法                       |
|    %E    |                       浮点数，e 记数法                       |
|    %f    |                     浮点数，十进制记数法                     |
|    %g    | 根据值的不同，自动选择 %f 或 %e。%e 格式用于指数小于 -4 或者大于或等于精度时 |
|    %G    | 根据值的不同，自动选择 %f 或 %E。%E 格式用于指数小于 -4 或者大于或等于精度时 |
|    %i    |                 有符号十进制整数（与%d相同）                 |
|    %o    |                       无符号八进制整数                       |
|    %p    |                             指针                             |
|    %s    |                            字符串                            |
|    %u    |                       无符号十进制整数                       |
|    %x    |            无符号十六进制整数，使用十六进制数 0f             |
|    %X    |            无符号十六进制整数，使用十六进制数 0F             |
|    %%    |                        打印一个百分号                        |



## 作用域 & 存储期 & 链接



### 作用域

|       类别       |                 说明                  |
| :--------------: | :-----------------------------------: |
|    *块作用域*    | 用{}括起来的，从声明开始到 "}" 结束。 |
|   *函数作用域*   |  goto（标识符）的作用域为整个函数。   |
| *函数原型作用域* |  函数声明开始，函数声明结束而结束。   |
|   *文件作用域*   |          整个文件或者程序。           |



### 链接

| 链接类别 |            说明            |
| :------: | :------------------------: |
| *无链接* |     只在其作用域内可见     |
| *内链接* | 在声明到文件结束都是可见的 |
| *外链接* | 多个文件或者整个程序都可见 |



### 存储期

|     类别     |                             说明                             |
| :----------: | :----------------------------------------------------------: |
| *静态存储期* |                   在整个程序都是占有内存的                   |
| *线程存储期* |   _Thread_local,其声明后会给每个线程分配一个单独的私有备份   |
| *自动存储期* |               局部变量通常都自动为 auto 存储期               |
| *动态存储期* | 就是用 new 或者 malloc 分配的内存，如果不主动释放，在整个程序都占有内存 |



### 存储类型

- auto（自动变量）
- register（寄存器变量）
- static（静态局部变量）
- extern 
- typedef



### 总结

| 存储类别       | 存储期 | 作用域 | 链接 | 声明方式                          |
| -------------- | ------ | ------ | ---- | --------------------------------- |
| *自动*         | 自动   | 块     | 无   | 块内                              |
| *寄存器*       | 自动   | 块     | 无   | 块内，使用关键字 **register**     |
| *静态外部链接* | 静态   | 文件   | 外部 | 所有函数外                        |
| *静态内部链接* | 静态   | 文件   | 内部 | 所有函数外，使用关键字 **static** |
| *静态无链接*   | 静态   | 块     | 无   | 块内，使用关键字 **static**       |

> register 声明后，并不一定会存到寄存器中，他只是一种请求。及时不存在寄存器中也不能对其取地址。同时可以存为register的类型可不多，因为有些类型太大了，寄存器存不下。
>
> 如果在函数中的内部存在一个与全局变量同名的局部变量，编译器不会报错，而是在函数中屏蔽全局变量（也就是说在这个函数中，全局变量不起作用）
>
> 如果在定义点之前的函数想引用该全局变量，则应该在引用之前使用 **extern** 对该变量作 “外部变量声明”，表示该变量是一个已经定义的外部变量

```C
#include <stdio.h>

void max(int x, int y);

void max(int x, int y)
{
    //外部变量声明
    extern int g_x;
    extern int g_y;
    g_x++;
    g_y++;
    /*code*/
}
//定义两个全局变量
int g_x = 10;
int g_y = 20;
```





## 字符串处理函数

* 获取字符串的长度：**strlen**
* 拷贝字符串：**strcpy** 和 **strncpy**（后者比前者多一个参数，用于约束字符数）
* 连接字符串：**strcat** 和 **strncat**（后者比前者多一个参数，用于约束字符数）
* 比较字符串：**strcmp** 和 **strncmp**（后者比前者多一个参数，用于约束字符数）

```C
char str[] = "Love";
char str2[] = "you";
char str3[100];
printf("%d",strlen(str));	//>>4
strcpy(str3, str);			//>>Love
strncpy(str3, str2, 3);		//>>youe(只复制了前三位，最后的e没有被覆盖)
strcat(str3, str);			//>>youeLove
strncat(str3, str2, 2);		//>>youeLoveyo
if(strcmp(str, str2))		//>>（从第一个字符开始依次对比每个字符的ASCII码，第一个字符串的字符小于第二个字符串的第一个字符，返回一个小于0的值，反之大于0的值。如果相同找下一个字符，完全相等返回0）
```



## 指针



### 定义指针

```C
//类型名 *指针变量名
int *pa;
```



### 取地址运算符 & 取值运算符

```C
//如果需要获取某个变量的地址，可以使用取地址运算符（&）
char *pa = &a;
int *pb = &f;

//如果需要访问指针变量指向的数据，可以使用取值运算符（*）
printf("%c, %d\n", *pa, *pb);

//指针大小占4个字节
printf("%d", sizeof(pa));		//>>>4
```

> 避免访问未初始化的指针

```C
int *a;		//野指针
*a = 123;
/*
指针 a 没有赋值地址，而是将一个常量赋值，这可能会覆盖掉一些系统内存，
但一般系统不会让你这么干，但也不要使用！！！
*/
```



### 指针和数组

> 数组名其实是数组第一个元素的地址！

```C
/*
用一个指针指向数组
*/
char *p;				//定义一个指针
char a[] = "Love";		//定义一个数组并初始化
p = a;					//语句1
p = &a[0];				//语句2
p+1;					//a[1]
```

> 当指针指向数组元素的时候，我们可以对**指针变量**进行**加减运算**，这样做的意义相当于指向距离**指针所在位置**向前或向后第n个元素。
>
> 对比标准的下标访问数组元素，这种使用指针进行间接访问的方法叫做指针法。
>
> p+1并不是简单地将地址加1，而是指向数组的下一个元素。



### 指针和数组的区别

> 数组名只是一个地址，而指针是一个左值。

```C
char str[] = "I love you";		//str 是一个地址常量不属于左值
char *target = str;				//*target 是一个左值
*str++;							//XXX
*target++;						//OOO

/*
按照优先级 ++ 运算符会先执行，但会在 * 运算符后进行自增。
*/
```

> lvalue 理解为 ***locator value*** **（特定位置的值）**，rvalue 则应该是 ***value of an expression*** **（表达式的值）**。单纯用左边（left-value）和右边（right-value）来理解是不全面的。
>
> **C 语言的术语 lvalue 指用于识别或定位一个存储位置的标识符。（注意：左值同时还必须是可改变的）**



### 指针数组和数组指针

> 指针数组是**数组**，数组指针是**指针**（看名字最后两字）

```C
int *p1[5];		//指针数组
int (*p2)[5];	//数组指针

char *p3[5] = {"I", "love", "you"};		//定义一个指针数组 
printf("%s\n", p3[1]);		//>>>love

/*以上的案例中格式化输出语句中不能写成 *p3[1]
因为会将返回第二个元素的第一个字符的地址，
不加 * 就会将第二个元素字符串返回
*/

int (*p4)[5];		//定义一个指向长度为 5 的 int 类型的数组指针
int temp[] = {1, 2, 3, 4, 5 };	//定义一个数组
p4 = &temp;	//将数组的地址赋值给指针，必须使用 & 如果不使用返回的就是该数组的第一个元素的地址，不是数组的地址
printf("%d\n", *(*p+4));	//()优先级高，*p 为 temp 数组的地址，再使用 * 取出地址中的第5个元素。


```

> **指针数组**是一个数组，每个数组元素存放一个指针变量
>
> **数组指针**是一个指针，它指向的是一个数组



### void指针和NULL指针

> void指针我们把它称之为通用指针，就是可以指向任意类型的数据。也就是说，任何类型的指针都可以赋值给void指针。

```C
void *p;
int num = 123;
int *pi = &num;
char *ps = "Love";

p = pi;
printf("%d", *(int *)p);	//建议加上强制类型转化

p = ps;
printf("%s", (char *)p);//因为取值是字符串，字符串会从第一个字符到 \0，所以不用 *
```

> 当你还不清楚要将指针初始化为什么地址时，请将它初始化NULL；在对指针进行解引用时，先检查该指针是否为NULL。这种策略可以为你今后编写大型程序节省大量的调试时间。

```C
#define NULL ((void *)0)	//NULL 是一个宏定义
```



### 指向指针的指针

```C
int num = 520;
int *p = &num;
int **pp = &p;		//指向指针的指针

//*pp就是将 &p 的值取出是 &num
//**pp 则是 520
```



### 指向常量的指针

> 指针可以修改为指向不同的常量
>
> 指针可以修改为指向不同的变量
>
> 可以通过解引用来读取指针指向的数据
>
> 不可以通过解引用修改指针指向的数据

```C
int num = 213;
const int cnum = 213;
int * const p = &num;			//指向非常量的常量指针
const int * const p2 = &num;	//指向常量的常量指针
p = &num;	//XXX
*p = 1024;	//OOO
```

* 指向非常量的常量指针
  * 指针自身不可以被修改
  * 指针指向的值可以被修改
* 指向常量的常量指针
  * 指针自身不可能被修改
  * 指针指向的值也不可以被修改



## 函数

```C
#include <stdio.h>
int max(int,int);		//定义变量，可以不写，但写了阅读性好，形参名可以不写
void shu(int arr[]);	//传递的是实参的地址，是可以在函数内修改实参的元素
void sum(int n, ...);	//可变参数，表明参数个数不确定

int max(int a, int b)
{
    /*code*/
}
```



### 指针函数

> 使用指针变量作为函数的返回值，就是指针函数。
>
> 不要返回局部变量的指针

```C
char * getStr();	//指针函数
```



### 函数指针

> 指向函数的指针

```C
int *p(int a);		//指针函数（就是一个返回int指针的函数）
int (*p)();		//函数指针（p可以和函数一样使用例子如下）

int *p(int a)
{
    /*code*/
}

int main()
{
    int (*fp)(int);		//定义一个函数指针
    fp = p;				//将函数的地址赋值给指针
    (*fp)(12);			//通过指针调用函数,可以写fp(12)但为了和普通函数区分开来
    
}
```



## 内存管理

```C
malloc	//申请动态内存空间
free	//释放动态内存空间
calloc	//申请并初始化一系列内存空间
realloc	//重新分配内存空间
```



### malloc

```C
//函数原型
void *malloc(size_t size);
```

> 1. **malloc** 函数向系统申请分配 size 个字节的内存空间，并返回一个指向这块空间的指针 
> 2. 如果函数调用成功，返回一个指向申请的内存空间的指针，由于返回类型是 void 指针（void *），所以它可以被转换成任何类型的数据；如果函数调用失败，返回值是 NULL 。另外，如果 size 参数设置为0，返回值也可能是 NULL，但这并不意味着函数调用失败。

```C
可以被转换成任何类型的数据int *ptr;
ptr = malloc(sizeof(int));	//空指针可以转换成任何类型，写(int *)可以增强语义
```



### free

```C
void free(void *ptr);
```

> **free** 函数释放 ptr 参数指向的内存空间。该内存空间必须是由 **malloc**、**calloc** 或 **realloc** 函数申请的。否则，该函数将导致未定义行为。如果 ptr 参数是 NULL，则不执行任何操作。注意：该函数并不会修改 ptr 参数的值，所以调用后它们仍然指向原来的地方（变为非法空间）。

```C
free(ptr);
```

> 导致内存泄漏主要有两种情况：
>
> * 隐式内存泄漏（即用完内存块没有及时使用 free 函数释放）
> * 丢失内存块地址（将申请内存块的指针修改为别的地址）



### calloc

```C
void *calloc(size_t nmemb, size_t size);
```

> **calloc** 函数在内存中动态地申请 **nmemb** 个长度为 **size** 的连续内存空间（即申请的总空间尺寸为 **nmemb * size**），这些内存空间全部被初始化为0。
>
> **calloc** 函数与 **malloc** 函数的一个重要区别是：
>
> * **calloc** 函数在申请完内存空间后，自动初始化该内存空间为零。
> * **malloc** 函数不进行初始化操作，里边数据是随机的

```C
int *ptr = (int *)calloc(8, sizeof(int));
```



### realloc

```C
void *realloc(void *ptr, size_t size);
```

> 1. **realloc** 函数修改 ptr 指向的内存空间大小为 size 字节
> 2. 如果新分配的内存空间比原来的大，则旧内存块的数据不会发生改变；如果新的内存空间大小小于旧的内存空间，可能会导致数据丢失，慎用！
> 3. 该函数将移动内存空间的数据并返回新的指针 
> 4. 如果 ptr 参数为 NULL ，那么调用该函数就向当于调用 **malloc(size)**
> 5. 如果 size 参数为 0，并且 ptr 参数不为 NULL，那么调用该函数就相当于调用**free(size)**
> 6. 除非 ptr 参数为NULL，否则 ptr 的值必须由先前调用 **malloc**、**calloc** 或 **realloc** 函数返回



### 初始化内存空间

> 以 **mem** 开头的函数被编入字符串标准库，函数的声明包含在 string.h 这个头文件中
>
> * **memset**			（使用一个常量字节填充内存空间）
> * **memcpy**           （拷贝内存空间）
> * **memmove**       （拷贝内存空间）
> * **memcmp**         （比较内存空间）
> * **memchr**           （在内存空间中搜索一个字符）

```C
#include <stdio.h>
#include <string.h>

void main(void)
{
    int *ptr = NULL;
    ptr = (int *)malloc(sizeof(int));
    memset(ptr, 0, sizeof(int));
}
```

 

### 内存布局规律

![image-20220125231606584](https://gitee.com/Fantasy2001/images/raw/master/Markdown/C%E8%AF%AD%E8%A8%80_%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80%E8%A7%84%E5%BE%8B.png)

1. **代码段**（Text segment）通常是指用来存放程序执行代码的一块内存区域。这部分区域的大小在程序运行前就已经确定，并且内存区域通常属于只读。在代码段中，也有可能包含一些只读的常数变量，例如字符串常量。
2. **数据段**（Initialized data segment）通常用来存放==已经初始化的全局变量和局部静态变量==
3. **BSS段**（Bss segment/Uninitialized data segment）通常是指用来存放程序中==未初始化的全局变量==的一块内存区域。BSS 是英文 Block Started by Symbol 的简称，这个区段中的数据在程序运行前将被==自动初始化为数字0。==
4. **堆**是用于存放进程运行中被动态分配的内存段，它的大小并不固定，可动态扩展或缩小。当进程调用 ==**malloc**== 等函数分配内存时，新分配的内存就被动态添加到堆上；当利用 ==**free**== 等函数释放内存时，被释放的内存从堆中被剔除。
5. **栈**一般指的就是平时听到的堆栈。栈是函数执行的内存区域，通常和堆共享同一片区域。==局部变量、函数参数、函数返回值。==



#### 堆和栈的区别

**申请方式：**

* 堆由程序员手动申请
* 栈由系统自动分配



**释放方式：**

* 堆由程序员手动释放
* 栈由系统自动释放



**生存周期**

* 堆的生存周期由动态申请到程序员主动释放为止，不同函数之间均可自由访问
* 栈的生存周期由函数调用开始到函数返回时结束，函数之间的局部变量不能互相访问



**发展方向**

* 堆和其他区段一样，都是从低地址向高地址发展
* 栈则相反，是由高地址向低地址发展



## 宏定义

要将 C 语言翻译成机器语言，简单来说需要两个步骤：编译 --> 链接

对于 GCC 来说，执行 gcc test.c 命令，其实相当于依次执行下面四个步骤：

- 预处理（Pre-Processing）-- 对 C 语言进行预处理，生成 test.i 文件
- 编译（Compiling）-- 将上一步生成的 test.i 文件编译生成汇编语言文件，后缀名为 test.s
- 汇编（Assembling）-- 将汇编语言文件 test.s 经过汇编，生成目标文件，后缀名为 test.o
- 链接（Linking）-- 将各个模块的 test.o 文件链接起来，生成最终的可执行文件



> *注：前三个步骤均属于编译过程。*



**预处理**

![image-20220126141146016](https://gitee.com/Fantasy2001/images/raw/master/Markdown/C%E8%AF%AD%E8%A8%80_%E9%A2%84%E5%A4%84%E7%90%86.png)



### 不带参数的宏定义

1. 为了和普通的变量进行区分，宏的名字通常我们约定是全部由大写字母组成
2. 宏定义只是简单地进行替换，并且由于预处理是在编译之前进行，而编译工作的任务之一就是语法检查，所以编译器不会对宏定义进行语法检查
3. 宏定义不是说明或语句，在末尾不必加分号
4. 宏定义的作用域是从定义的位置开始到整个程序结束
5. 可以用 #undef 来终止宏定义的作用域
6. 宏定义允许嵌套

```C
#include <stdio.h>
#define PI 3.14
#define O PI * 12		//嵌套在宏定义中使用了别的宏

int main(void)
{
#undef PI				//不需要缩进
    print("%f", PI);	//报错
    return 0;
}
```



### 带参数的宏定义

```C
#include <stdio.h>
#define MAX(x,y) (((x) > (y)) ? (x) : (y))	//不用声明类型，不用括号使用表达式会出问题

int main(void)
{
    int a = 10, b = 12;
    printf("最大的数：%d", MAX(a,b));
    return 0;
}
```



### 内联函数

> 引入内联函数来解决程序中函数调用的效率问题
>
> 函数每一次使用都需要在栈中开辟空间，因为宏定义只是简单的替换，但使用宏定义函数，会有参数操作时的问题，因此使用 **inline** 关键字进行嵌入替换，也不会出现宏定义的参数问题

```c
#include <stdio.h>

inline int square(int x);		//使用 inline 关键字

inline int square(int x)		//使用 inline 关键字
{
    /*code*/
}
```

> 因为内联函数嵌入调用者代码中的操作是一种优化操作，因此只有进行优化编译时才会执行代码嵌入处理。若编译过程中没有使用优化选项 ‘-o’，那么内联函数的代码就不会被真正地嵌入到调用者代码中，而是只作为普通函数调用来处理。所以编译的时候应该这么写；gcc name.c -o && ./a.out



### \# 和 \#\#

1. **\#** 和 **\#\#** 是两个预处理运算符。
2. 在带参数的宏定义中，**#** 运算符后面应该跟一个参数，预处理器会把这个参数转换为一个字符串。
3. **\#\#** 运算符被称为记号连接运算符，比如我们可以使用 **\#\#** 运算符连接两个参数。 

```C
#include <stdio.h>
#define STR(s) # s
#define TOGETHER(x,y) x ## y

int main(void)
{
    printf(STR(Hello %s), STR(World));		//Hello World
    printf("%d\n", TOGETHER(6,9));			//69
    return 0;
}
```



### 可变参数 

```C
#include <stdio.h>

#define PRINT(...) printf(# __VA_ARGS__)	//__VA_ARGS__(全部可变参数)

int main(void)
{
    PRINT(123,456,789);		//123456789
    return 0;
}
```



## 结构体



### 声明

```C
#include <stdio.h>

/* struct 结构体名称 结构体变量名 */
struct Book
{
    char title[128];
    char author[40];
    float price;
    unsigned int date;
    char publisher[40];
};		//分号结尾，可以在反大括号后写变量名{code} Book;

int main(void)
{
    struct Book book;
    return 0;
}
```

要访问结构体成员，用（ **.** ）运算符。比如 book.title。



### 初始化变量

```C
//方法一
struct Book book = {
    "1",
    "2",
    "3"
};

//方法二（C99后）
struct Book book = {.price = 48.8};		//只初始化一个成员其他都是未初始化

//方法三（指定成员就不用按顺序初始化）
struct Book book = {
    .publisher = "1",
    .price = 48.8,
    .date = 20171111
}

//例子
struct A 
{
    char a;
    int b;
    char c;
} a = {'x', 520, 'o'};			//在定义时也可初始化，与变量一样。

printf("size of a = %d\n", sizeof(a));		//内存对齐后的结果：12
```

 

### 结构体嵌套

```C
struct Book
{
    char title[128];
    char author[40];
    float price;
    unsigned int date;			//用另一个结构体作为成员
    char publisher[40];
} book = {					//定义并初始化
    .date = {2022,1,27}
};

struct Date
{
    int year;
    int month;
    int day;
};

printf("%d-%d-%d", book.date.year, book.date.month, book.date.day);	//访问
```



### 结构体数组

1. 第一种方法是在声明结构体的时候进行定义
2. 第二种是先声明一个结构体类型（比如上面 Book），再用此类型定义一个结构体数组

```C
//一
struct 结构体名称
{
    结构体成员;
} 数组名[长度];

//二
struct 结构体名称
{
    结构体成员;
};
struct 结构体名称 数组名[长度];		//定义结构体数组
```



### 结构体指针

```C
struct Book * pt;
pt = &book;		//使用取值运算符，因为结构体的变量名不指向结构体的地址
```

> 访问结构体成员的两种方法：
>
> 1. (*结构体指针).成员名		
>
>    //因为 **.** 的优先级比 **\*** 高，用小括号先解引用，再用 **.** 获取成员值
>
> 2. 结构体指针 -> 成员名



### 结构体变量

和普通变量一致，都可作为参数，返回值等使用

```C
struct Date
{
    int year;
    int month;
    int day;
};

struct Date getDate(struct Date date);
```

> 结构体变量可能导致空间或时间上的开销大，用指针！

```C
struct Date
{
    int year;
    int month;
    int day;
};

void getDate(struct Date *date);

void getDate(struct Date *date)
{
    printf("%d-%d-%d", date->year, date->month, date->day); 
}
```



### 动态申请结构体

```C
struct Date
{
    int year;
    int month;
    int day;
};

struct Date *date1, *date2;
date1 = (struct Date *)malloc(sizeof(struct Date));
date2 = (struct Date *)malloc(sizeof(struct Date));
/*code*/
free(date1);	//释放
free(date2);	//释放
```



## typedef

> 相比起宏定义的直接替换，**typedef** 是对类型的封装。（起个别名）

```C
struct Date {
    int year;
    int month;
    int day;
};

int main(void)
{
    struct Date *date;
	date = (struct *Date)malloc(sizeof(struct Date));//分配内存，避免野指针
    return 0;
}

/*————————————————————————————————————————————*/

typedef struct Date {
    int year;
    int month;
    int day;
}DATE, *PDATE;		//定义两个别名，使用结构的话用DATE来代替，指针就用*PDATE代替

int main(void)
{
    struct Date *date;
	date = (PDATE)malloc(sizeof(Date));//分配内存，避免野指针
    return 0;
}
```



## 共用体

> 共用体的所有成员共享同一个内存地址！

```C
union 共用体名称
{
    共用体成员1;
    共用体成员2;
    共用体成员3;
    ...
}

union Test 				//可以没有名字，比如Test，但需要在}后定义变量。
{
    int i;
    double pi;
    char str[6];
};

/*main*/
union Test test;

test.i = 520;
test.pi = 3.14;
strcpy(test.str, "Hello");

printf("%p\n", &test.i); 		//输出地址相同 
printf("%p\n", &test.pi);		//输出地址相同
printf("%p\n", &test.str);		//输出地址相同

printf("%d\n",test.i);			//显示错误
printf("%.2f\n",test.pi);		//显示错误
printf("%s\n",test.str);		//显示正确

/*因为使用的是同一块地址，对他们赋值会互相的覆盖，所以最后赋值的 str 正确显示
在某一刻只能使用其中一个成员，不能同时使用。
共用体占用的内存足够存储其成员最大的尺寸，但有内存对齐所以不一定等于最大内存*/
```



## 枚举类型

> 在实际编程中，有些数据的取值往往是有限的，只能是非常少量的整数，并且最好为每个值都取一个名字，以方便在后续代码中使用，比如一个星期只有七天，一年只有十二个月，一个班每周有六门课程等。
>
> 如果一个变量只有几种可能的值，那么就可以将其定义为枚举（enumeration）类型
>
> `define`命令虽然能解决问题，但也带来了不小的副作用，导致宏名过多，代码松散，看起来总有点不舒服。

```C
//声明
enum 枚举类型名称 {枚举值名称, 枚举值名称...};
//定义
enum 枚举类型名称 枚举变量1, 枚举变量2;

int main(void)
{
    //为枚举值默认从 0 开始，往后逐个加 1（递增）；0, 1, 2, 3...
    enum week {Mon=1, Tues, Web, Thurs, Fri, Sat, Sun} day;
    scanf("%d", &day);
    
     switch(day){
        case Mon: puts("Monday"); break;
        case Tues: puts("Tuesday"); break;
        case Wed: puts("Wednesday"); break;
        case Thurs: puts("Thursday"); break;
        case Fri: puts("Friday"); break;
        case Sat: puts("Saturday"); break;
        case Sun: puts("Sunday"); break;
        default: puts("Error!");
    }
    
    return 0;
}
```



## 位域

> 有些数据在存储时并不需要占用一个完整的字节，只需要占用一个或几个二进制位即可。例如开关只有通电和断电两种状态，用 0 和 1 表示足以，也就是用一个二进位。正是基于这种考虑，C语言又提供了一种叫做位域的数据结构。
>
> 在结构体定义时，在结构体成员后面使用冒号（**:**）和数字来表示该成员所占的位数

```C
#include <stdio.h>

int main(void) 
{
    struct Test
    {
        unsigned int a:1;		
        unsigned int b:1;
        unsigned int c:2;
        int : 20;			//位域成员可以没有名称，只给出数据类型和位宽
        //无名位域一般用来作填充或者调整成员位置。因为没有名称，无名位域不能使用。
    }
    
    struct Tesst test;
    test.a = 0;
    test.b = 1;
    test.c = 2;
    
    printf("%d %d %d", test.a, test.b, test.c);		//0 1 2
    printf("%d", sizeof(test));						//4
    
    return 0;
}
```



## 逻辑位运算符

| 运算符 |   含义   | 优先级 |  举例  | 说明                                                         |
| :----: | :------: | :----: | :----: | :----------------------------------------------------------- |
|   ~    | 按位取反 |   高   |   ~a   | 如果a为1，~a为0；<br>如果 a 为 0，~a 为1。                   |
|   &    |  按位与  |   中   | a & b  | 只有 a 和 b同时为 1，结果才为 1；<br>只要 a 和 b 其中一个为 0，结果为0。 |
|   ^    | 按位异或 |   低   | a ^ b  | 如果 a 和 b 不同，其结果为 1；<br>如果 a 和 b相同，其结果为0。 |
|   \|   |  按位或  |  最低  | a \| b | 只要 a 和 b 其中一个为 1，结果为1；<br>只有 a 和 b 同时为 0，结果为 0。 |

> 除了按位取反只有一个操作数之外，其它三个都可以跟赋值号（**=**）结合



## 移位

| 运算符 |   意义   |  示例  |           结果            |
| :----: | :------: | :----: | :-----------------------: |
|   <<   | 向左移位 | x << y | x 的每个位向左移动 y 个位 |
|   >>   | 向右移位 | x >> y | x 的每个位向右移动 y 个位 |

**11**111100 << 2;

111100**00**		//左移**2**位，<u>11</u>移掉剩**6**位左移，最后两位补**0**



111111**00** >> 2;

**00**111111		//右移**2**位，<u>00</u>移掉剩**6**位右移，最前两位补**0**



> 左移、右移运算符右边的操作数如果是为负数，或者右边的操作数大于左边操作数支持的最大宽度，那么表达式的结果均是属于 “未定义行为”。
>
> 左边的操作数是有符号还是无符号数其实也对移位运算符有着不同的影响。无符号数肯定没问题，因为这时候变量里边所有的位都用于表示该数值大小。但如果是有符号数，那就要区别对待了，因为有符号数的左边第一位是符号位，所以如果恰好这个操作数个负数，那么移动之后是否覆盖符号位的决定权还是落到了编译器上。



## 文件操作



### 文件打开

> fopen 函数用于打开一个文件并返回文件指针。

**函数原型：**

```C
#include <stdio.h>
...
FILE *fopen(const char *path, const char *mode);
```

| 参数 | 含义                                                         |
| :--: | :----------------------------------------------------------- |
| path | 该参数是一个 C 语言字符串，指定了待打开的文件路径和文件名（见备注） |
| mode | 1. 该参数是一个 C 语言字符串，指定了文件的打开模式<br>2.下面列举了所有可使用的<a href="#mode">打开模式</a> |

<a name="mode">mode</a>

| 模式 | 描述                                                         |
| :--: | :----------------------------------------------------------- |
| "r"  | 1. 以只读的模式打开一个文本文件，从文件头开始读取<br>2. 该文件文本必须存在 |
| "w"  | 1. 以只写的模式打开一个文本文件，从文件头开始写入<br>2. 如果文件不存在则创建一个新的文件<br>3. 如果文件已存在则将文件的长度截断为 0（重新写入的内容将覆盖原有的所有内容） |
| "a"  | 1. 以追加的模式打开一个文本文件，从文件末尾追加内容<br>2. 如果文件不存在则创建一个新的文件 |
| "r+" | 1. 以读和写的模式打开一个文本文件，从文件头开始读取和写入<br>2. 该文件必须存在<br>3. 该模式不会将文件的长度截断为 0（只覆盖重新写如的内容，原有的内容保留） |
| "w+" | 1. 以读和写的模式打开一个文本文件，从文件头开始读取和写入<br>2. 如果文件不存在则创建一个新的文件<br>3. 如果文件已存在则将文件的长度截断为 0（重新写入的内容将覆盖原有的所有内容） |
| "a+" | 1. 以读和最加的模式打开一个文本文件<br>2. 如果文件不存在则创建一个新的文件<br>3. 读取是从文件头开始，而写入则是在文件末尾追加 |
| "b"  | 1. 与上面 6 种模式均可结合（"rb","wb","ab","r+b","w+b","a+b"）<br>2. 其描述的含义一样，只不过操作的对象是二进制文件（见备注） |



**返回值：**

1. 如果文件打开成功，则返回一个指向 **FILE** 结构的文件指针；
2. 如果文件打开失败，则返回 **NULL** 并设置 *errno* 为指定的错误

**备注：**

1. path 参数可以是相对路径（../fishc.txt）也可以是绝对路径（/home/FishC/fishc.txt），如果只给出文件名而不包含路径，则表示该文件在当前文件夹中

2. 从本质上来说，文本文件也是属于二进制文件的，只不过它存放的是相应的字符编码值。

3. 打开方式要区分文本模式和二进制模式的原因，主要是因为换行符的问题。C 语言用 \n 表示换行符，Unix 系统用 \n，Windows 系统用 \r\n，Mac 系统则用 \r。如果在 Windows 系统上以文本模式打开一个文件，从文件读到的 \r\n 将会自动转换成 \n，而写入文件则将 \n 替换为 \r\n。但如果以二进制模式打开则不会做这样的转换。Unix 系统的换行符跟 C 语言是一致的，所以不管以文本模式打开还是二进制模式打开，结果都是一样的。



### 文件关闭

> fclose 函数用于关闭先前由 fopen 函数打开的文件。
>
> fclose 函数会将缓冲区内的数据写入文件中，并释放系统所提供的文件资源。fclose 函数用于关闭先前由 fopen 函数打开的文件。
>
> fclose 函数会将缓冲区内的数据写入文件中，并释放系统所提供的文件资源。

**函数原型**

```C
#include <stdio.h>
...
int fclose(FILE *fp);	//fp：指向一个待关闭的文件指针
```

**返回值：**

1. 如果文件关闭成功，返回值是 0；

2. 如果文件关闭失败，返回值是 EOF，并设置 errno 为指定的错误。

**备注：**

> 磁盘已满、设备出错或者 I/O 错误均可能导致 fclose 函数调用失败。



```C
#include <stdio.h>

int main(void)
{
    FILE *fp;
    int ch;
    
    if((fp = fopen("hello.txt", "r")) == NULL)
    {
        printf("打开文件失败！\n");
        return 0;
    }
    
    while((ch = getc(fp)) != EOF)
    {
        putchar(ch);
    }
   
    fclose(fp);
    return 0;
}
```

