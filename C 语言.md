# C 语言



## 转义字符

![image-20220116174517583](https://gitee.com/Fantasy2001/images/raw/master/Markdown/C%E8%AF%AD%E8%A8%80/%E8%BD%AC%E4%B9%89%E5%AD%97%E7%AC%A6%E8%A1%A8.png)



## 常量

```c
#define NAME Value		//常量的定义
const int MONTHS = 12;		//const用于限定一个变量为只读
```



## 数据类型

![image-20220117160552263](https://gitee.com/Fantasy2001/images/raw/master/Markdown/C%E8%AF%AD%E8%A8%80/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B.png)



### 基本类型

![image-20220117161528056](https://gitee.com/Fantasy2001/images/raw/master/Markdown/C%E8%AF%AD%E8%A8%80/%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B.png)



### sizeof 运算符

```C
/*有以下三种写法*/
sizeof(object);		//sizeof(对象);
sizeof(type_name);	//sizeof(类型);
sizeof object;		//sizeof 对象;

/*例子*/
int i = 100;
sizeof(i);
sizeof(int);
sizeof i;
```



### signed 和 unsigned

> signed 带符号位
>
> unsigned 不带符号位

假设一个char为一个字节也就是八位，第一位为符号位，剩余的比特位用于表示值。所以取值范围是127~-128（00000000 = 十进制的 0 ，11111111 = -1）



### 补码

一字节有八位，第一位是符号位，0 表示 +，1表示 -
00000111（3）
11111000（先取反）
11111001（再+1，因为00000000是十进制中的0，所以负数比正数多1。因此多了这一步）
11111001（-3）
（3 - 3）== 00000111 + 11111001 = 100000000
这里的结果是 9 位，对于一个字节单元来说，这左边的 1 是“溢出”的了，会被自动舍弃，因此结果就变成了 00000000。

> 补码的好处：
>
> 1. 解决了符号的表示的问题。
> 2. 在计算机中，利用电子器件的特点实现补码和真值、原码之间的相互转换，非常容易。
> 3. 补码表示统一了符号位和数值位，使得符号位可以和数值位一起直接参与运算，这也为后面设计乘法器除法器等运算器件提供了极大的方便。



## 格式化输出/输入

**转换说明及其打印的输出结果**

| 转换说明 |                             输出                             |
| :------: | :----------------------------------------------------------: |
|    %a    |           浮点数、十六进制数和 p 记书法（C99/C11）           |
|    %A    |           浮点数、十六进制数和 p 记数法（C99/C11）           |
|    %c    |                           单个字符                           |
|    %d    |                       有符号十进制整数                       |
|    %e    |                       浮点数，e 记数法                       |
|    %E    |                       浮点数，e 记数法                       |
|    %f    |                     浮点数，十进制记数法                     |
|    %g    | 根据值的不同，自动选择 %f 或 %e。%e 格式用于指数小于 -4 或者大于或等于精度时 |
|    %G    | 根据值的不同，自动选择 %f 或 %E。%E 格式用于指数小于 -4 或者大于或等于精度时 |
|    %i    |                 有符号十进制整数（与%d相同）                 |
|    %o    |                       无符号八进制整数                       |
|    %p    |                             指针                             |
|    %s    |                            字符串                            |
|    %u    |                       无符号十进制整数                       |
|    %x    |            无符号十六进制整数，使用十六进制数 0f             |
|    %X    |            无符号十六进制整数，使用十六进制数 0F             |
|    %%    |                        打印一个百分号                        |



## 作用域 & 存储期 & 链接



### 作用域

|       类别       |                 说明                  |
| :--------------: | :-----------------------------------: |
|    *块作用域*    | 用{}括起来的，从声明开始到 "}" 结束。 |
|   *函数作用域*   |  goto（标识符）的作用域为整个函数。   |
| *函数原型作用域* |  函数声明开始，函数声明结束而结束。   |
|   *文件作用域*   |          整个文件或者程序。           |



### 链接

| 链接类别 |            说明            |
| :------: | :------------------------: |
| *无链接* |     只在其作用域内可见     |
| *内链接* | 在声明到文件结束都是可见的 |
| *外链接* | 多个文件或者整个程序都可见 |



### 存储期

|     类别     |                             说明                             |
| :----------: | :----------------------------------------------------------: |
| *静态存储期* |                   在整个程序都是占有内存的                   |
| *线程存储期* |   _Thread_local,其声明后会给每个线程分配一个单独的私有备份   |
| *自动存储期* |               局部变量通常都自动为 auto 存储期               |
| *动态存储期* | 就是用 new 或者 malloc 分配的内存，如果不主动释放，在整个程序都占有内存 |



### 存储类型

- auto（自动变量）
- register（寄存器变量）
- static（静态局部变量）
- extern
- typedef



### 总结

| 存储类别       | 存储期 | 作用域 | 链接 | 声明方式                          |
| -------------- | ------ | ------ | ---- | --------------------------------- |
| *自动*         | 自动   | 块     | 无   | 块内                              |
| *寄存器*       | 自动   | 块     | 无   | 块内，使用关键字 **register**     |
| *静态外部链接* | 静态   | 文件   | 外部 | 所有函数外                        |
| *静态内部链接* | 静态   | 文件   | 内部 | 所有函数外，使用关键字 **static** |
| *静态无链接*   | 静态   | 块     | 无   | 块内，使用关键字 **static**       |

> register 声明后，并不一定会存到寄存器中，他只是一种请求。及时不存在寄存器中也不能对其取地址。同时可以存为register的类型可不多，因为有些类型太大了，寄存器存不下。



## 字符串处理函数

* 获取字符串的长度：**strlen**
* 拷贝字符串：**strcpy** 和 **strncpy**（后者比前者多一个参数，用于约束字符数）
* 连接字符串：**strcat** 和 **strncat**（后者比前者多一个参数，用于约束字符数）
* 比较字符串：**strcmp** 和 **strncmp**（后者比前者多一个参数，用于约束字符数）

```C
char str[] = "Love";
char str2[] = "you";
char str3[100];
printf("%d",strlen(str));	//>>4
strcpy(str3, str);			//>>Love
strncpy(str3, str2, 3);		//>>youe(只复制了前三位，最后的e没有被覆盖)
strcat(str3, str);			//>>youeLove
strncat(str3, str2, 2);		//>>youeLoveyo
if(strcmp(str, str2))		//>>（从第一个字符开始依次对比每个字符的ASCII码，第一个字符串的字符小于第二个字符串的第一个字符，返回一个小于0的值，反之大于0的值。如果相同找下一个字符，完全相等返回0）
```



## 指针



### 定义指针

```C
//类型名 *指针变量名
int *pa;
```



### 取地址运算符 & 取值运算符

```C
//如果需要获取某个变量的地址，可以使用取地址运算符（&）
char *pa = &a;
int *pb = &f;

//如果需要访问指针变量指向的数据，可以使用取值运算符（*）
printf("%c, %d\n", *pa, *pb);

//指针大小占4个字节
printf("%d", sizeof(pa));		//>>>4
```

> 避免访问未初始化的指针

```C
int *a;		//野指针
*a = 123;
/*
指针 a 没有赋值地址，而是将一个常量赋值，这可能会覆盖掉一些系统内存，
但一般系统不会让你这么干，但也不要使用！！！
*/
```



### 指针和数组

> 数组名其实是数组第一个元素的地址！

```C
/*
用一个指针指向数组
*/
char *p;				//定义一个指针
char a[] = "Love";		//定义一个数组并初始化
p = a;					//语句1
p = &a[0];				//语句2
p+1;					//a[1]
```

> 当指针指向数组元素的时候，我们可以对**指针变量**进行**加减运算**，这样做的意义相当于指向距离**指针所在位置**向前或向后第n个元素。
>
> 对比标准的下标访问数组元素，这种使用指针进行间接访问的方法叫做指针法。
>
> p+1并不是简单地将地址加1，而是指向数组的下一个元素。



### 指针和数组的区别

> 数组名只是一个地址，而指针是一个左值。

```C
char str[] = "I love you";		//str 是一个地址常量不属于左值
char *target = str;				//*target 是一个左值
*str++;							//XXX
*target++;						//OOO

/*
按照优先级 ++ 运算符会先执行，但会在 * 运算符后进行自增。
*/
```

> lvalue 理解为 ***locator value*** **（特定位置的值）**，rvalue 则应该是 ***value of an expression*** **（表达式的值）**。单纯用左边（left-value）和右边（right-value）来理解是不全面的。
>
> **C 语言的术语 lvalue 指用于识别或定位一个存储位置的标识符。（注意：左值同时还必须是可改变的）**



### 指针数组和数组指针

> 指针数组是**数组**，数组指针是**指针**（看名字最后两字）

```C
int *p1[5];		//指针数组
int (*p2)[5];	//数组指针

char *p3[5] = {"I", "love", "you"};		//定义一个指针数组 
printf("%s\n", p3[1]);		//>>>love

/*以上的案例中格式化输出语句中不能写成 *p3[1]
因为会将返回第二个元素的第一个字符的地址，
不加 * 就会将第二个元素字符串返回
*/

int (*p4)[5];		//定义一个指向长度为 5 的 int 类型的数组指针
int temp[] = {1, 2, 3, 4, 5 };	//定义一个数组
p4 = &temp;	//将数组的地址赋值给指针，必须使用 & 如果不使用返回的就是该数组的第一个元素的地址，不是数组的地址
printf("%d\n", *(*p+4));	//()优先级高，*p 为 temp 数组的地址，再使用 * 取出地址中的第5个元素。


```

> **指针数组**是一个数组，每个数组元素存放一个指针变量
>
> **数组指针**是一个指针，它指向的是一个数组



### void指针和NULL指针

> void指针我们把它称之为通用指针，就是可以指向任意类型的数据。也就是说，任何类型的指针都可以赋值给void指针。

```C
void *p;
int num = 123;
int *pi = &num;
char *ps = "Love";

p = pi;
printf("%d", *(int *)p);	//建议加上强制类型转化

p = ps;
printf("%s", (char *)p);//因为取值是字符串，字符串会从第一个字符到 \0，所以不用 *
```

> 当你还不清楚要将指针初始化为什么地址时，请将它初始化NULL；在对指针进行解引用时，先检查该指针是否为NULL。这种策略可以为你今后编写大型程序节省大量的调试时间。

```C
#define NULL ((void *)0)	//NULL 是一个宏定义
```

